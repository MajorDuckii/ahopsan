\section*{Appendix}

A machine state $S$ contain many registers and memories entries, which store various symbolic values.
By design, after executing a basic block $BB$,
its final machine state $S$ is passed to $BB$'s successors only when $S$ is determined as interesting.
Here, ``interesting'' means register and memory values contain new data patterns in terms of $BB$'s previous executions.

The determining function is named \textit{MergeState()} and listed as Algorithm~\ref{alg:mergestate}.
Specifically, it tries to add all entries of $S$ into $BB$'s historical record set \textit{OutSuperState}, by invoking function \textit{WidenValueSet()}.
State $S$ contains interesting information only when the \textit{OutSuperState} is changed, i.e. widened with new items.

\begin{algorithm}
    \caption{Merge output state $OS$ into $BB.OutSuperState$ }
    \footnotesize
    \begin{algorithmic}[1]
        \Function{MergeState}{$BB$, $OS$}
        \State $SuperSt$ = BB.OutSuperState.clone()

        % Merge registers
        \State
        \For {$(reg.id, reg.Vals)$ in OS.regs} \Comment{Merge register values}
        \If {reg.id in SuperSt.keys()}
        \State WidenValueSet(SuperSt[reg.id], reg.Vals)
        \Else
        \State SuperSt[reg.id] = reg.Vals
        \EndIf
        \EndFor

        % Merge memory values
        \State
        \For {$(mem.id, mem.Vals)$ in OS.mems} \Comment{Merge memory values}
        \If{mem.id in SuperSt.keys()}
        \State WidenValueSet(SuperSt[mem.id], mem.Vals)
        \Else
        \State SuperSt[mem.id] = mem.Vals
        \EndIf
        \EndFor

        % Test widening results
        \State
        \If{SuperSt != BB.OutSuperState} \Comment{Test merge results}
        \State BB.OutSuperState = SuperSt \Comment{state $S$ should bring new pattens}
        \State return true \Comment{Return true if $S$ carries new pattern knowledge}
        \EndIf
        \State return false \Comment{Otherwise, return false}
        \EndFunction
    \end{algorithmic}
    \label{alg:mergestate}
\end{algorithm}


The Algorithm~\ref{alg:widenvalueset} for widening a value-set is depicted as function \textit{WidenValueSet()}.
It mainly applies heuristic rules to analyze if a value-set $VS$ brings new information to a historical value-set $SS$.
If yes, $SS$ would be updated with new information, otherwise be appended with a top value $\top$.
Once $SS$ contains $\top$, then it is locked out from updating.
In most scenarios, the heuristic rules can find out corresponding patterns and lock the widening procedure appropriately.
To counter a few scenarios that make the heuristic rules failure,
this algorithm uses a guard condition $sizeof(SS.VS) > upbound$ to forcibly terminate the widening.
The upbound value is affected by the complexity of the target function, here using $6$ as an example.


\begin{algorithm}
    \caption{Widening set $SS$ with value-set $VS$}
    \footnotesize
    \begin{algorithmic}[1]
        \Function{WidenValueSet}{$SS$, $VS$}
        \If{ $\top$ in SS.VS}
        \State return  \Comment{Doesn't accept new values}
        \EndIf

        \State
        \State $cupSet$ = SS.VS $\cup$ VS
        \If{cupSet == SuperSet}
        \State return \Comment{All values in VS are already contained in SS.VS}
        \EndIf

        \State
        \If{sizeof(SS.VS) $>$ $6$} \Comment{ExecFunction is terminable}
        \State SS.VS.append($\top$)
        \EndIf

        \State
        \State $subSet$ = cupSet - SS.VS
        \If {WidenWithPatterns(SS,cupSet,subSet)} \Comment{Apply heuristic rules}
        \State SS.VS = cupSet;
        \State return
        \EndIf


        \EndFunction
    \end{algorithmic}
    \label{alg:widenvalueset}
\end{algorithm}