\section{System Design}


\newcounter{dsgn}
\renewcommand\yphn[1]{\stepcounter{dsgn} \textcolor{blue} {\thedsgn.} \yphl{#1}}


We design a semantic-aware memory access profiler and
a semantic-aware address sanitizer.

\subsection{Languate Level Semantics}
To parse the semantics of each memory access is critical.

Currently, we define the following semantics: array access or struct access, pointer dereference.

\yphn{Inputs}

We exploit the source code.

\yphn{Outputs}
For a program, both profiler and sanitizer would generate their binaries.


\subsection{Semantic Analysis}
An important task is to collect the semantics of memory access.

\subsection{Memory object organization}
Do we need to use variable size red-zones for different kinds of objects?

\subsubsection{Heap Buffers}

\subsubsection{Stack buffers}

\subsubsection{Internal buffers}
An object sometimes contains a buffer inside itself.
This buffer may be security-sensitive if its adjacent members are function pointers.

For such an object, we create red-zones to surround the buffers, similar to what Asan does on stack buffers.

\subsection{Instrumentation}

Do we need to do another check after a loop?

\subsection{Exception Handling}


\begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{llvm}
  entry:
    %p.addr = alloca i8*, align 8
    store i8* %p, i8** %p.addr, align 8
    br label %while.cond  
  while.cond:
    %0 = load i8*, i8** %p.addr, align 8
    %1 = load i8, i8* %0, align 1
    %tobool = icmp ne i8 %1, 0
    br i1 %tobool, label %while.body, label %while.end
  while.body:    
    %2 = load i8*, i8** %p.addr, align 8
    %3 = load i8, i8* %2, align 1
    %conv = sext i8 %3 to i32
    %4 = load i32, i32* @globalx, align 4
    %add = add nsw i32 %4, %conv
    store i32 %add, i32* @globalx, align 4
    %5 = load i8*, i8** %p.addr, align 8
    %incdec.ptr = getelementptr inbounds i8, i8* %5, i32 1
    store i8* %incdec.ptr, i8** %p.addr, align 8
    br label %while.cond  
  while.end:
    ret void
\end{minted}

A sound algorithm.

Symbolic address-set Analsysis based on Symbolic IR execution.

This is really an old problem.






\subsection{Symbolic Address-set Analysis}
For IR instruction, simply idenfitied by the line number.
On my symbolic execution engine, collect the accessed address by each instruction.

Then analsys the memory access patterns, to
idenitfy array access an struct member access.




\subsection{Instrumentation}

\subsection{Data Layout}



Suppose now we know where are the arracy access and datamember access.
They how we desingh the data layout?


\begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{cpp}
  if (isFarAway(ptr, ptr_lastchk)) {
    if (isOOB(ptr)) error(); // ...
  }
\end{minted}

1. use fixed stride;
abs(ptr - ptr_lastchk) < 64;
It doesn't need memory access.
To guarantees safe memory access. SO the smallest size of red-zones is 64 bytes.

The memory overhead would be considerable.


if (isFarAway(ptr, ptr_lastchk)) {
    if(isOOB(ptr)) error();
    ptr_lastchk = ptr;
  }

\begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{cpp}
  if ((p ^ p_lastchk) < 64) {
    if (isOOB(p)) error();
    p_lastchk = p;
  }
\end{minted}


2. use variable stride;
abs(ptr-ptr_lastchk) < ptr_rdsize;



\begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{cpp}
  if ((p ^ p_lastchk) < p_rdsize) {
    if (isOOB(p)) error();
    if (isFirstChk(p_lastchk)) p_rdsize = rdsize(p);
    p_lastchk = p;
  }
\end{minted}


We use 32 bit registers. Give a change to compile if it can make good use of a 64bit regitesr as two 32 bit registes.

The memory is stroed.


All size information are stroed in anarray, can be simply extracted from ptr.

~2x memory overhead.

So it needs one more memory access.


So each data object contains some metadata, the size of data.

\yphn{ISOOB}
So for each memory address, we can round to the start address.
So if the data is overwrite or overread, then it would ovwertiet the cookies.
This bechaviour would be detected.

For heaps buffers, we do like above. Use a lowfat style check.

For stack, how to protect it?

We need a final check for arrasy access and object access.
But don't need for database dereference.
They should be a not of data-pointers.


For stack buffers, can we use the asan style checks?
How we store metadata and set the red-zone?


\yphn{How does Asan work?}
The instrumentation and data layout of Asan.

\yphn{How does Lowfat work?}
The instrumentation and data layout of Lowfat.

\subsection{Symbolic Execution Engine}

Our symbolic execution engine executes LLVM-IR instructions in interpreting mode.
The target virtual machine (VM) of this engine uses a model which is consistent with the LLVM-IR CPU model.
Specifically, the VM's CPU has unlimited registers and can access any memory slots.
The contents stored in registers and memories are initialzied with symbolic values at machine startup.
This rule is also applied to real arguments to functions.
All symbolic values are in strings. A symbolic value may consisit with two parts, a pure symbolic value and a digital value.


Dereferencing a memory address would get a value prefixed with ``V\_'' to its address.
For example, to execute the instruction
``\textit{\%2=load i32*,i32**\%p.addr}'' would make \textit{\%2=V\_\%p.addr}, if memory \textit{\%p.addr} is accessed for the first time.


The symbolic engine supports \textit{partial} mathematic operations, including addition, subtraction, multiplication, and division.
Here, ``parital'' means these operations can apply on pure symbolic parts of two operators or their digital parts.
Symbolic value \textit{V\_\%p.addr} adds \textit{2} would generate symbolic value \textit{V\_\%p.addr+2},
and \textit{V\_\%p.addr+2} add \textit{4} would generate \textit{V\_\%p.addr+6}.
Symbolic value \textit{V\_\%p.addr+6} minus \textit{V\_\%p.addr+2} generates \textit{4}.

Algorithm:
The exeuction enginne schedule the execution basic block by block.
The schedule units are basiuc block.
Each basic block are feed by a seriours of configuartion.
Each configuration is consist with a set of rgistesrs status.
The entry basick block start with an empty basic block.
The partermeters.
Eveay new occurentcy of a regiuster is denoted by a symbol value.
Every IR instructoin is.
The register staus changes along with the IR execution.

Machine status: Register status. + Memory status.

Change the status along the IR execution.

All registesrs and memroy slots are initialized with symbolic values.
Therefore, the first read of a registe or a memoery adddress would get a symbolic values.

Every Function is an execution unit.

Merge operations

