\section{System Design}

\newcounter{dsgn}
\renewcommand\yphn[1]{\stepcounter{dsgn} \textcolor{blue} {\thedsgn.} \yphl{#1}}

This work applies symbolic address-set analysis to extract memory access semantics from LLVM-IR instructions.
In turn, this analysis procedure is built upon a symbolic execution engine,
which interprets IR instructions on a virtual machine with unlimited registers and memories.
The instrumentation pass then exploits memory access semantics to insert boundary checks before memory accesses.
For understanding, this section elaborates the design choices in a top-down fashion, i.e. starting from the highest abstract-level.

\subsection{High-Level Program Semantics}


\subsection{IR-level Memory Access Semantics}

% An important task is to collect the semantics of memory access.

% \subsection{Memory object organization}
% Do we need to use variable size red-zones for different kinds of objects?

% \subsubsection{Heap Buffers}

% \subsubsection{Stack buffers}

% \subsubsection{Internal buffers}
% An object sometimes contains a buffer inside itself.
% This buffer may be security-sensitive if its adjacent members are function pointers.

% For such an object, we create red-zones to surround the buffers, similar to what Asan does on stack buffers.

% \subsection{Instrumentation}

% Do we need to do another check after a loop?

% \subsection{Exception Handling}

\subsection{Memory Access Instrumentation}


% For array access:

% \begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{cpp}
%   if (isFarAway(ptr, ptr_lastchk)) {
%     if (isOOB(ptr)) error(); // ...
%   }
% \end{minted}

% We have two choices:


% Chocie 1. Use fixed stride: This is simple, but memory overhead would be considerable.

% Suppose the smallest red-zones size is 64 bytes.

% \begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{cpp}
%   if ((p ^ p_lastchk) < 64) {
%     if (isOOB(p)) error();
%     p_lastchk = p;
%   }
% \end{minted}


% Choice 2. use variable stride.
% This is flexible to set the red-zone size for differnt object thus can decrease memory overhead.
% But it would increase register pressure.


% \begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{cpp}
%   if ((p ^ p_lastchk) < p_rdsize) {
%     if (isOOB(p)) error();
%     if (isFirstChk(p_lastchk)) p_rdsize = rdsize(p);
%     p_lastchk = p;
%   }
% \end{minted}




\subsection{Symbolic Execution Engine}

The symbolic execution engine executes LLVM-IR instructions in interpreting mode.
The target virtual machine (VM) of this engine is modeled with unlimited registers and memories.
Thus, this VM model is compatible with the LLVM-IR CPU model.
The contents stored in registers and memories are initialzied with symbolic values at machine startup.
This rule is also applied to function arguments.

A symbolic value is a plural value that consists of two parts, i.e. a purely symbolic value and a digital value.
For simplification, the pure symbolic value is a lexical string.
Sometimes a symbolic value would be stringified.
Technically, this operation is accomplished by formating both parts into substrings and then concatenating them together.
Dereferencing a memory address would get a symbolic value, whose pure symbolic part is a ``V\_'' prefix plus the stringified address.
For example, to execute the instruction
``\textit{\%2=load i32*,i32**\%p.addr}'' would assign regiser \textit{\%2} with a symbolic value \textit{(V\_\%p.addr, 0)},
if memory \textit{\%p.addr} is accessed for the first time.

The symbolic engine supports \textit{partial} mathematic operations, including addition, subtraction, multiplication, and division.
Here, ``partial'' means these operations apply only on either pure symbolic parts or digital parts of two operands.
For instance, symbolic value \textit{(V\_\%p.addr, 0)} plus \textit{2} (can be denoted as \textit{(NULL, 2)}) makes symbolic value \textit{(V\_\%p.addr, 2)},
while symbolic value \textit{(V\_\%p.addr, 6)} minus \textit{(V\_\%p.addr, 2)} makes \textit{(NULL, 4)}).

This engine mainly focuse on helping in-procudre memory access analysis,
so functions are the execution units.
In other words, the VM is reset before executing any function, therefore all possible registers and memories are initialized with fresh contents.
The initial machine state before executing is updated with parameters to a given function.
This state is fed to the entry block.
In turn, the entry block (the same as any other block) feeds its output state to its successors.
The VM continues this procedure until all basic blocks do not have any new machine states to execute.
Algorithm~\ref{alg:execfunction} depicts this procedure as function \textit{ExecFunction}.

\begin{algorithm}
  \caption{Execute function $F$ with parameters $PARMS$}
  \footnotesize
  \begin{algorithmic}[1]
    \Function{ExecFunction}{$F$}
    \For{$bb$ in F.BBs} \Comment{Initialize machine states for all basic blocks}
    \State bb.InStates = {$\emptyset$} \Comment{Current available input states}
    \State bb.OutSuperState = {$\emptyset$} \Comment{A super set of all output states}
    \EndFor
    \State F.entryBB.InStates.push(\{PARMS\}) \Comment{Create a state for entry block}
    \State

    \Do \Comment{Execute blocks which have new machine states}

    \State $bCont$ = false
    \For{$bb$ in F.BBs}
    \While {$s$ = bb.InStates.pop()}
    \State ExecBasicBlock(bb, s)
    \State bCont = true;
    \EndWhile
    \EndFor

    \doWhile(bCont)
    \EndFunction
  \end{algorithmic}
  \label{alg:execfunction}
\end{algorithm}


\begin{algorithm}
  \caption{Execute basic block $BB$ with machine state $S$}
  \footnotesize
  \begin{algorithmic}[1]
    \Function{ExecBasicBlock}{$BB$, $S$}
    \State $outS$ = S.clone()  \Comment{Execute on a clone copy of $S$}
    \For{$I$ in BB}
    \Switch{I.Opc}
    \Case{$load$:}
    \State execInstrLoad(I, outS) \Comment{Execute $I$ and update $outS$}
    \EndCase
    \Case{$store$:}
    \State execInstrStore(I, outS)
    \EndCase
    \Case{$...$:}
    \State execInstr...(I, outS)
    \EndCase
    \EndSwitch
    \State CollectRes(I) \Comment{Allow external code to collect execution results}
    \EndFor

    \State
    \If{MergeState(BB, outS)} \Comment{True if $outS$ contains new things}
    \For{$bb$ in BB.Succs} \Comment{Add $outS$ to successor blocks as inputs}
    \State bb.InStates.push(s.clone())
    \EndFor
    \EndIf

    \EndFunction
  \end{algorithmic}
  \label{alg:execbasicblock}
\end{algorithm}

To execute a basic block $BB$ on a machine state $S$, the engine interprets all the LLVM-IR instructions in order.
Algorithm~\ref{alg:execbasicblock} depicts this procedure as function \textit{ExecBasicBlock}.
Roughly, the interpreting operations on an IR instruction are consistent with the instruction's semantics definition.
Note that, because our final goal is to extract memory access semantics,
so an instruction whose execution does have effects on memory access is ignored.
The execution results of an IR instruction are applied on $S$ as state changes.
The final state of $S$ is propagated to $BB$'s successors conditionally,
depending on whether $S$ can bring new value patterns/modes to $BB$'s previous executions.
This conditional test can decrease the number of machine states to basic blocks,
therefore the engine would be terminated at some time even the function contains loops.
More details about this conditional test can be checked out in the appendix section.


The engine also provides an interface named \textit{CollectRes()} for external code to acquire
the execution results of IR instructions.
The other parts of the engine are decoupled with external code.


\subsection{Symbolic Address-set Analysis}

A simple while-loop listed below would be converted into an IR instruction sequence as shown in listing~\ref{code:whileIR}.
$$void \ foo(char *p) \{ while(*p)\{globalx \mathrel{+}= *p; p ++;\} \}$$
% \begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{cpp}
%   void foo(char *p) { while(*p){globalx += *p; p++;} }
% \end{minted}


\begin{listing}
  \begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{llvm}
  entry:
    %p.addr = alloca i8*, align 8
    store i8* %p, i8** %p.addr, align 8
    br label %while.cond  
  while.cond:
    %0 = load i8*, i8** %p.addr, align 8
    %1 = load i8, i8* %0, align 1
    %tobool = icmp ne i8 %1, 0
    br i1 %tobool, label %while.body, label %while.end
  while.body:    
    %2 = load i8*, i8** %p.addr, align 8
    %3 = load i8, i8* %2, align 1
    %conv = sext i8 %3 to i32
    %4 = load i32, i32* @globalx, align 4
    %add = add nsw i32 %4, %conv
    store i32 %add, i32* @globalx, align 4
    %5 = load i8*, i8** %p.addr, align 8
    %incdec.ptr = getelementptr inbounds i8, i8* %5, i32 1
    store i8* %incdec.ptr, i8** %p.addr, align 8
    br label %while.cond  
  while.end:
    ret void
\end{minted}
  \caption{IR instructions to a simple C/C++ while-loop.}
  \label{code:whileIR}
\end{listing}

\subsection{Data Layout}



% We use 32 bit registers. Give a change to compile if it can make good use of a 64bit regitesr as two 32 bit registes.

% The memory is stroed.


% All size information are stroed in anarray, can be simply extracted from ptr.

% ~2x memory overhead.

% So it needs one more memory access.


% So each data object contains some metadata, the size of data.

% \yphn{ISOOB}
% So for each memory address, we can round to the start address.
% So if the data is overwrite or overread, then it would ovwertiet the cookies.
% This bechaviour would be detected.

% For heaps buffers, we do like above. Use a lowfat style check.

% For stack, how to protect it?

% We need a final check for arrasy access and object access.
% But don't need for database dereference.
% They should be a not of data-pointers.


% For stack buffers, can we use the asan style checks?
% How we store metadata and set the red-zone?


% \yphn{How does Asan work?}
% The instrumentation and data layout of Asan.

% \yphn{How does Lowfat work?}
% The instrumentation and data layout of Lowfat.


% inputs of

% The execution uni
% The exeuction enginne schedule the execution basic block by block.
% The schedule units are basiuc block.
% Each basic block are feed by a seriours of configuartion.
% Each configuration is consist with a set of rgistesrs status.
% The entry basick block start with an empty basic block.
% The partermeters.
% Eveay new occurentcy of a regiuster is denoted by a symbol value.
% Every IR instructoin is.
% The register staus changes along with the IR execution.

% Machine status: Register status. + Memory status.

% Change the status along the IR execution.

% All registesrs and memroy slots are initialized with symbolic values.
% Therefore, the first read of a registe or a memoery adddress would get a symbolic values.

% Every Function is an execution unit.

% Merge operations

