\section{Background and Related Works}

\newcounter{bkrw}
\renewcommand\yphn[1]{\stepcounter{bkrw} \textcolor{blue} {\thebkrw.} \yphl{#1}}

The following code snippet list the code generated by Asan.
It is in IR (intermediate representation) instructions instead of assembly code.
Although it does not exactly match the assembly code, the basic block level layout is almost the same.
Because IR contains rich semantic information.
Easier to understand the assembly code.

As the IR instructions show, they are a lot of memory access.
But most of them operate on local stack temporary variables, used as register spilling backup.
But most of them are not interesting.

\yphn{Array element access}


\begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{cpp}
  int access_array(int *p, int len) {
    for (int i = 0; i < len; i++) global_sum += p[i];
  }
\end{minted}


\begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{LLVM}
  ;sum += p[i];
  %2 = load i32*, i32** %p.addr, align 8
  %arrayidx = getelementptr i32, i32* %2, i64 %i
  %4 = load i32, i32* %arrayidx, align 4
  %5 = load i32, i32* %sum, align 4
  %add = add nsw i32 %5, %4
  store i32 %add, i32* %sum, align 4
\end{minted}

\yphn{Struct member access}


\begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{cpp}
  struct O { int x, y, z; };
  void access_object(struct O *obj) {
    global_sum += obj->x + obj->y + obj->z;
  }
\end{minted}


\begin{minted}[fontsize=\scriptsize,frame=single,linenos,numbersep=-6pt]{LLVM}
  ;sum += obj->x;
  ;sum += obj->y;
  %0 = load %struct.O*, %struct.O** %obj.addr, align 8
  %x = getelementptr %struct.O, %struct.O* %0, i32 0, i32 0
  %1 = load i32, i32* %x, align 4
  %2 = load i32, i32* %sum, align 4
  %add = add nsw i32 %2, %1
  store i32 %add, i32* %sum, align 4
  %3 = load %struct.O*, %struct.O** %obj.addr, align 8
  %y = getelementptr %struct.O, %struct.O* %3, i32 0, i32 1
  %4 = load i32, i32* %y, align 4
  %5 = load i32, i32* %sum, align 4
  %add1 = add nsw i32 %5, %4
  store i32 %add1, i32* %sum, align 4
\end{minted}
